{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 111, "column": 0}, "map": {"version":3,"sources":["file://D%3A/auto-trading-bot/fe/src/app/api/bot-data/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\nimport fs from 'fs';\nimport path from 'path';\nimport { exec } from 'child_process';\nimport { promisify } from 'util';\nimport jwt from 'jsonwebtoken';\n\nconst execPromise = promisify(exec);\nconst readFilePromise = promisify(fs.readFile);\nconst existsPromise = promisify(fs.exists);\n\nconst JWT_SECRET = 'your-secret-key-for-trading-bot-authentication';\n\n// Helper function to verify JWT token\nconst verifyToken = (token: string) => {\n  try {\n    return jwt.verify(token, JWT_SECRET);\n  } catch (error) {\n    return null;\n  }\n};\n\n// Helper function to check authentication\nconst checkAuth = (request: NextRequest) => {\n  // For browser requests, check Authorization header\n  const authHeader = request.headers.get('Authorization');\n  if (authHeader && authHeader.startsWith('Bearer ')) {\n    const token = authHeader.split(' ')[1];\n    const decoded = verifyToken(token);\n    if (decoded) {\n      return true;\n    }\n  }\n  \n  // For API requests from the frontend, check the token in the request body\n  return false;\n};\n\n// Create a mock data store for transaction history\n// In a real implementation, this would come from a database or log files\nconst transactionStore: Record<string, any[]> = {\n  azbit: [],\n  p2pb2b: []\n};\n\n// Function to parse log files or other data sources\nasync function getOrderBookData(botId: string) {\n  try {\n    // In a real implementation, this would read from actual log files or a database\n    // For now, we'll return mock data that's more realistic\n    \n    // Simulate fetching real data from the bot\n    const baseDir = process.cwd().replace(/\\\\fe$/, '');\n    const orderBookPath = path.join(baseDir, `${botId}-orderbook.json`);\n    \n    // Check if the file exists\n    const exists = await existsPromise(orderBookPath);\n    \n    if (exists) {\n      // Read the file\n      const data = await readFilePromise(orderBookPath, 'utf8');\n      return JSON.parse(data);\n    }\n    \n    // If file doesn't exist, return mock data\n    return {\n      lowestSell: botId === 'azbit' ? 0.29 : 0.0025,\n      highestBuy: botId === 'azbit' ? 0.27 : 0.0023,\n      spread: botId === 'azbit' ? 0.02 : 0.0002,\n      lastOrderType: Math.random() > 0.5 ? 'buy' : 'sell'\n    };\n  } catch (error) {\n    console.error(`Error getting order book data for ${botId}:`, error);\n    // Return default data on error\n    return {\n      lowestSell: botId === 'azbit' ? 0.29 : 0.0025,\n      highestBuy: botId === 'azbit' ? 0.27 : 0.0023,\n      spread: botId === 'azbit' ? 0.02 : 0.0002,\n      lastOrderType: null\n    };\n  }\n}\n\nasync function getBalanceData(botId: string) {\n  try {\n    // In a real implementation, this would read from actual log files or a database\n    const baseDir = process.cwd().replace(/\\\\fe$/, '');\n    const balancePath = path.join(baseDir, `${botId}-balance.json`);\n    \n    // Check if the file exists\n    const exists = await existsPromise(balancePath);\n    \n    if (exists) {\n      // Read the file\n      const data = await readFilePromise(balancePath, 'utf8');\n      return JSON.parse(data);\n    }\n    \n    // If file doesn't exist, return mock data\n    return {\n      crypto: botId === 'azbit' ? 1.5 : 5000,\n      usdt: 5000 + Math.random() * 10000\n    };\n  } catch (error) {\n    console.error(`Error getting balance data for ${botId}:`, error);\n    // Return default data on error\n    return {\n      crypto: botId === 'azbit' ? 1.5 : 5000,\n      usdt: 5000\n    };\n  }\n}\n\nasync function getTransactionHistory(botId: string) {\n  try {\n    // In a real implementation, this would read from actual log files or a database\n    const baseDir = process.cwd().replace(/\\\\fe$/, '');\n    const transactionPath = path.join(baseDir, `${botId}-transactions.json`);\n    \n    // Check if the file exists\n    const exists = await existsPromise(transactionPath);\n    \n    if (exists) {\n      // Read the file\n      const data = await readFilePromise(transactionPath, 'utf8');\n      return JSON.parse(data);\n    }\n    \n    // If no transactions exist yet, return empty array\n    if (!transactionStore[botId] || transactionStore[botId].length === 0) {\n      // Generate some initial mock transactions\n      const cryptoCurrency = botId === 'azbit' ? 'BTCR' : 'BRIL';\n      transactionStore[botId] = Array.from({ length: 5 }, (_, i) => {\n        const type = i % 2 === 0 ? 'buy' : 'sell';\n        const price = botId === 'azbit' ? 0.28 + (Math.random() * 0.02) : 0.0024 + (Math.random() * 0.0002);\n        const amount = botId === 'azbit' ? 0.1 + (Math.random() * 0.5) : 1000 + (Math.random() * 5000);\n        return {\n          id: `tx-${botId}-${Date.now()}-${i}`,\n          type,\n          amount,\n          price,\n          total: price * amount,\n          timestamp: new Date(Date.now() - i * 3600000 * 2).toLocaleString(),\n          status: 'completed'\n        };\n      });\n    }\n    \n    return transactionStore[botId];\n  } catch (error) {\n    console.error(`Error getting transaction history for ${botId}:`, error);\n    return [];\n  }\n}\n\nasync function getPriceHistory(botId: string) {\n  try {\n    // In a real implementation, this would read from actual log files or a database\n    const baseDir = process.cwd().replace(/\\\\fe$/, '');\n    const historyPath = path.join(baseDir, `${botId}-price-history.json`);\n    \n    // Check if the file exists\n    const exists = await existsPromise(historyPath);\n    \n    if (exists) {\n      // Read the file\n      const data = await readFilePromise(historyPath, 'utf8');\n      return JSON.parse(data);\n    }\n    \n    // If file doesn't exist, return mock data\n    const basePrice = botId === 'azbit' ? 0.28 : 0.0024;\n    const baseSpread = botId === 'azbit' ? 0.02 : 0.0002;\n    \n    return Array.from({ length: 6 }, (_, i) => ({\n      time: new Date(Date.now() - i * 3600000).toLocaleTimeString(),\n      lowestSell: basePrice + (Math.random() * 0.02),\n      highestBuy: basePrice - (Math.random() * 0.02),\n      spread: baseSpread + (Math.random() * (baseSpread * 0.1))\n    })).reverse();\n  } catch (error) {\n    console.error(`Error getting price history for ${botId}:`, error);\n    return [];\n  }\n}\n\nexport async function GET(request: NextRequest) {\n  try {\n    // Check authentication\n    if (!checkAuth(request)) {\n      return NextResponse.json({ success: false, error: 'Unauthorized' }, { status: 401 });\n    }\n    \n    const url = new URL(request.url);\n    const botId = url.searchParams.get('botId');\n    \n    if (!botId || !['azbit', 'p2pb2b'].includes(botId)) {\n      return NextResponse.json({ success: false, error: 'Invalid bot ID' }, { status: 400 });\n    }\n    \n    // Get all the data in parallel\n    const [orderBook, balance, transactions, priceHistory] = await Promise.all([\n      getOrderBookData(botId),\n      getBalanceData(botId),\n      getTransactionHistory(botId),\n      getPriceHistory(botId)\n    ]);\n    \n    return NextResponse.json({ \n      success: true, \n      data: {\n        orderBook,\n        balance,\n        transactions,\n        priceHistory,\n        tradingPair: botId === 'azbit' ? 'BTCR/USDT' : 'BRIL/USDT'\n      }\n    });\n  } catch (error: any) {\n    console.error('Error getting bot data:', error);\n    return NextResponse.json({ \n      success: false, \n      error: error.message || 'An error occurred' \n    }, { status: 500 });\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 335, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}